# -*- coding: utf-8 -*-
"""Line_fault.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LcNoNAvQv2rxjku89Y7LZVhAv5vp-_yv
"""

def controller_decentralized(v, q_t, p_t, K_p, K_q):
    """
    Decentralized safe reinforcement learning for inverter-based voltage control
    """
    p = p_t + K_q * (v - 1)
    q = q_t + K_p * (v - 1)
    return p, q


def controller_centralized(v0, R, X, p_min, p_max, q_min, q_max, ctrl_cost_p=1e-6, ctrl_cost_q=1e-9, v_cost=1,):
    """
    Centralized optimal power flow for inverter-based voltage control
    Positive current injection direction is defined as out of a node.
    :param v0: slack bus voltage vector, float
    :param R: resistance matrix, shape=(N, N)
    :param X: reactance matrix, shape=(N, N)
    :param p_min: minimum active power injection, shape=(N,)
    :param p_max: maximum active power injection, shape=(N,)
    :param q_min: minimum reactive power injection, shape=(N,)
    :param q_max: maximum reactive power injection, shape=(N,)
    :param ctrl_cost_p: real power control cost weight, float
    :param ctrl_cost_q: reactive power control cost weight, float
    :param v_cost: voltage deviation cost weight, float
    :return: optimal active and reactive power injections (per-unit normalized), shape=(N), shape=(N)
    """
    # Compute the optimal control action
    N = R.shape[0]
    p_pu = cp.Variable(N)
    q_pu = cp.Variable(N)
    objective = cp.Minimize(
        # ctrl_cost_p * cp.sum_squares(p_pu) +
        # ctrl_cost_q * cp.sum_squares(q_pu) +
        cp.quad_form(v0 - 2 * (R @ cp.multiply(p_pu, p_max) + X @ cp.multiply(q_pu, q_max)) - 1, np.diag(np.ones(N) * v_cost))
    )
    assert (p_min <= p_max).all(), (p_min, p_max)
    assert (q_min <= q_max).all(), (q_min, q_max)
    constraints = [
        cp.multiply(p_pu, p_max) >= p_min,
        cp.multiply(p_pu, p_max) <= p_max,
        cp.multiply(q_pu, q_max) >= q_min,
        cp.multiply(q_pu, q_max) <= q_max
    ]
    prob = cp.Problem(objective, constraints)
    prob.solve()
    assert prob.status == 'optimal', prob.status
    return p_pu.value, q_pu.value


def compute_andes_v0(
    ss,
    p,
    q,
    load_bus_idx,
    load_idx,
    v0_dt,
    gen_bus_trip_time=1.0,
    gen_trip_name="GENROU_2",
):
    """
    :param ss: AndesSimulator object
    :param p: active power injection vector, float
    :param q: reactive power injection vector, float
    :param load_bus_idx: index of the load bus in the AndesSimulator
    :param v0_dt: time step for the simulation, float
    :param gen_bus_trip_time: time at which the generator trips, float
    :param gen_trip_name: name of the generator to trip, str
    :return: voltage at load_bus_idx, float
    """
    # Change the load real and reactive power and continue simulation
    # We are *not* re-running power flow here; we are continuing dynamics with a
    # new scheduled load level going forward (piecewise-constant change).
    # Positive is load, negative is generation
    ss.PQ.Ppf.v[load_idx] = p / ss.config.mva      # Change load power. Ppf is an array of 11 elements
    ss.PQ.Qpf.v[load_idx] = q / ss.config.mva      # Change load power. Qpf is an array of 11 elements
    ss.TDS.config.tf += v0_dt   # Simulation end time (seconds)

    # Trip the generator
    # if ss.TDS.config.tf >= gen_bus_trip_time:
    #     status = ss.SynGen.alter("u", gen_trip_name, 0)
    #     assert status

    # Run one step
    ss.TDS.config.no_tqdm = True
    ss.TDS.run(tstep=v0_dt, no_summary=True, progress=False)
    # ss.dae.ts.y is the global state vector bus voltages, shape = (T, N)
    v0 = ss.dae.ts.y[-1,ss.Bus.v.a][load_bus_idx]

    return v0


def run_simulation(
    circuit_data,
    bus_data,
    controller_type,
    compute_pwr_file='data/compute-power-readings/llama_b16_i512_o128_tp4/nvidiasmi_monitor.csv',
    stiff_grid=False,
    v0_file='data/record_trajectory_LossGen_t0.001.pckl',
    v0_dt=1e-2,
    resample_dt=1e-2,
    sim_length=3,
    compute_flexibility=0.2,
    cooling_flexibility=0.2,
    CENTRALIZED__CTRL_DELAY_STEPS=2,
    K_p_path='data/DecentralizedGain/trained_kq_vulcan.pckl',
    K_q_path='data/DecentralizedGain/trained_kq_vulcan.pckl',
    LOAD_BUS_IDX=1,
    LOAD_IDX=1,
):
    """
    Run the simulation with either decentralized or centralized control.
    :param circuit_data: list of dict, see circuit_data.py for details
    :param bus_data: dict of dict, see circuit_data.py for details
    :param compute_pwr_file: str, path to the compute power file
    :param v0_file: str, path to the v0 file
    :param v0_dt: float, time step of the v0 file
    :param resample_dt: float, time step to resample the data
    :param compute_flexibility: float, fraction of compute power that can be controlled
    :param cooling_flexibility: float, fraction of cooling power that can be controlled
    :param CENTRALIZED__CTRL_DELAY_STEPS: int, number of time steps delay for centralized control

    :return: None
    """
    # Load data
    R_matrix, X_matrix, C_matrix, node_list, edge_list = \
        single_phase_lindistflow(circuit_data)
    N = len(node_list) - 1

    t0, t1 = '2023/10/18 17:41:36.473', '2023/10/18 17:42:22.703'
    keys = {'t': 'timestamp', 'p': 'power.draw [W]'}
    compute_power = load_compute_power(compute_pwr_file, t0, t1, keys)

    if stiff_grid:
        keys = {'v0': 'record_trajectory'}
        v0 = load_v0(v0_file, keys, v0_dt)
        data = {'compute_power': compute_power, 'v0': v0}
        aligned_data = align_data(data, resample_dt)
        T = len(aligned_data['t'])
        print(f"Loaded data with {C_matrix.shape} nodes and edges and {T} time steps.")
    else:
        assert resample_dt == v0_dt, (resample_dt, v0_dt)
        !andes misc -C
        ss = andes.load(andes.get_case("ieee14/ieee14_fault.xlsx"), setup=False)
        ss.Fault.alter('tc', 1, 1.5)
        ss.Fault.alter('bus', 1, 8)
        # ss = andes.load("data/andes/ieee14.raw", addfile="data/andes/ieee14.dyr", setup=False)
        # Add a Toggle that disconnects generator `GENROU_2` at t=1 s
        # assert len(ss.Toggle.u.v) == 0, ss.Toggle.as_df()
        ss.setup()
        # calculate power flow: use constant power model for PQ loads
        # ss.PQ.config.p2p = 1
        # ss.PQ.config.q2q = 1
        # ss.PQ.config.p2z = 0
        # ss.PQ.config.q2z = 0
        # ss.PQ.pq2z = 0              # turn off under-voltage PQ-to-Z conversion
        # Run the power-flow (steady-state) solution to get initial operating point.
        ss.PFlow.run()
        ss.TDS.config.criteria = 0  # temporarily turn off stability criteria based on angle separation
        ss.TDS.config.tf = 0

        # Load and align compute_power data
        data = {'compute_power': compute_power}
        aligned_data = align_data(data, resample_dt, t_end=sim_length)
        T = len(aligned_data['t'])

    # Simulation parameters
    p_min, p_max, q_min, q_max = np.zeros((N, T)), np.zeros((N, T)), np.zeros((N, T)), np.zeros((N, T))
    p_no_control, q_no_control = np.zeros((N, T)), np.zeros((N, T))
    for n, node in enumerate(node_list[1:]):
        if bus_data[node]['type'] == 'compute':
            p_no_control[n] = bus_data[node]['pmax'] * aligned_data['compute_power_factor']
            p_min[n] = p_no_control[n] * (1 - compute_flexibility)
            p_max[n] = p_no_control[n]
        elif bus_data[node]['type'] == 'cooling':
            p_no_control[n] = bus_data[node]['pmax'] * np.mean(aligned_data['compute_power_factor'])
            p_min[n] = p_no_control[n] * (1 - cooling_flexibility)
            p_max[n] = p_no_control[n]
        else:
            if 'pmin' in bus_data[node]:
                p_min[n] = bus_data[node]['pmin']
            if 'pmax' in bus_data[node]:
                p_max[n] = bus_data[node]['pmax']
            if 'qmin' in bus_data[node]:
                q_min[n] = bus_data[node]['qmin']
            if 'qmax' in bus_data[node]:
                q_max[n] = bus_data[node]['qmax']

    sim_results = {
        't': aligned_data['t'],
        'v0': aligned_data['v0'] if stiff_grid else np.ones((T,)),
        'compute_power_factor': aligned_data['compute_power_factor'],
        'no_control': np.zeros((N, T)),
        'v_ctrl': np.zeros((N, T)),
        'p_ctrl': np.zeros((N, T)),
        'q_ctrl': np.zeros((N, T)),
        'p_no_ctrl': p_no_control,
        'q_no_ctrl': q_no_control,
    }
    sim_results['p_ctrl'][:, :T] = p_no_control
    sim_results['q_ctrl'][:, :T] = q_no_control

    if controller_type == 'decentralized':
        f = open("data/DecentralizedGain/trained_kq_kp_microsoft.pckl", 'rb')
        K_p, K_q = pickle.load(f)
        f.close()
        K_p, K_q = K_p.flatten(), K_q.flatten()

    if stiff_grid:
        v0 = aligned_data['v0'][0]
    else:
        v0 = compute_andes_v0(ss, p_no_control[:, 0].sum(), q_no_control[:, 0].sum(), LOAD_BUS_IDX, LOAD_IDX, v0_dt)
    v = v0 - 2 * (R_matrix @ p_no_control[:, 0] + X_matrix @ q_no_control[:, 0])

    for t in tqdm(range(T)):
        # Compute voltage without control
        sim_results['no_control'][:, t] = v
        # Apply centralized control
        if controller_type == 'decentralized':
            if t < T - 1:
                p_ctrl_t = sim_results['p_ctrl'][:, t]
                q_ctrl_t = sim_results['q_ctrl'][:, t]
                p_ctrl_t1, q_ctrl_t1 = controller_decentralized(v, q_ctrl_t, p_ctrl_t, K_p, K_q)
                p_ctrl_t1 = np.minimum(np.maximum(p_ctrl_t1, p_min[:, t]), p_max[:, t])
                q_ctrl_t1 = np.minimum(np.maximum(q_ctrl_t1, q_min[:, t]), q_max[:, t])
                sim_results['p_ctrl'][:, t+1] = p_ctrl_t1
                sim_results['q_ctrl'][:, t+1] = q_ctrl_t1
        elif controller_type == 'centralized':
            if t + CENTRALIZED__CTRL_DELAY_STEPS < T:
                p_pu_t, q_pu_t = controller_centralized(v0, R_matrix, X_matrix, p_min[:, t], p_max[:, t], q_min[:, t], q_max[:, t])
                # We use p_max, q_max as the per unit base for control actions
                sim_results['p_ctrl'][:, t + CENTRALIZED__CTRL_DELAY_STEPS] = p_max[:, t + CENTRALIZED__CTRL_DELAY_STEPS] * p_pu_t
                sim_results['q_ctrl'][:, t + CENTRALIZED__CTRL_DELAY_STEPS] = q_max[:, t + CENTRALIZED__CTRL_DELAY_STEPS] * q_pu_t
        # Compute the voltage at next time step
        v0 = aligned_data['v0'][t+1] if stiff_grid else \
            compute_andes_v0(ss, sim_results['p_ctrl'][:, t].sum(), sim_results['q_ctrl'][:, t].sum(), LOAD_BUS_IDX, LOAD_IDX, v0_dt)
        v = v0 - 2 * (R_matrix @ sim_results['p_ctrl'][:, t] + X_matrix @ sim_results['q_ctrl'][:, t])
        sim_results['v_ctrl'][:, t] = v
    return sim_results


def plot_simulation(t, V, P, Q, title, nodes_to_plot=None, out_path='temp', ext='png', figsize=(12, 3)):
    N = V.shape[0]
    if not nodes_to_plot:
        nodes_to_plot = list(range(min(10, N)))

    fig, axes = plt.subplots(1, 3, figsize=figsize, constrained_layout=False)
    fig.suptitle(title)

    # Voltages
    for i in nodes_to_plot:
        axes[0].plot(t, V[i, :], label=f"Node {i+1}")
    axes[0].set_xlabel("time(s)")
    axes[0].set_ylabel("V (p.u.)")
    axes[0].grid(True, alpha=0.3)

    # Action P
    for i in nodes_to_plot:
        axes[1].plot(t, P[i, :], label=f"Node {i+1}")
    axes[1].set_xlabel("time(s)")
    axes[1].set_ylabel("Action P")
    axes[1].grid(True, alpha=0.3)

    # Action Q
    for i in nodes_to_plot:
        axes[2].plot(t, Q[i, :], label=f"Node {i+1}")
    axes[2].set_xlabel("time(s)")
    axes[2].set_ylabel("Action Q")
    axes[2].grid(True, alpha=0.3)

    plt.legend()
    plt.tight_layout()
    os.makedirs(out_path, exist_ok=True)
    plt.savefig(os.path.join(out_path, f"{title}.{ext}"))


if __name__ == "__main__":
    # sim_results_cen = run_simulation(vulcan_circuit_data2, vulcan_bus_data2, 'centralized')
    # plot_simulation(sim_results_cen['t'], sim_results_cen['v_ctrl'], sim_results_cen['p_ctrl'], sim_results_cen['q_ctrl'], "With Centralized Controller")
    # plot_simulation(sim_results_cen['t'], sim_results_cen['no_control'], sim_results_cen['p_no_ctrl'], sim_results_cen['q_no_ctrl'], "Without control")
    sim_results_dec = run_simulation(vulcan_circuit_data2, vulcan_bus_data2, 'decentralized')
    plot_simulation(sim_results_dec['t'], sim_results_dec['v_ctrl'], sim_results_dec['p_ctrl'], sim_results_dec['q_ctrl'], "With Decentralized Controller")